# 条款 17：理解特殊成员函数的生成

​		Item 17: Understand special member function generation

## 特殊成员函数

在C++术语中，**特殊成员函数**是指C++自己生成的函数；

C++98 有四个：默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符，这些函数仅在需要的时候才生成；

C++11 特殊成员新增：移动构造函数和移动赋值运算符：

````c++
class Widget {
public:
    …
    Widget(Widget&& rhs);               //移动构造函数
    Widget& operator=(Widget&& rhs);    //移动赋值运算符
    …
};
````

生成和行为的规则类似于拷贝系列；

移动操作仅在需要的时候生成，如果生成了，就会对类的non-static数据成员执行逐成员的移动，如果不支持移动就执行拷贝操作；



## 生成移动擦操作的条件

所以仅当下面条件成立时才会生成移动操作（当需要时）：

- 类中没有拷贝操作
- 类中没有移动操作
- 类中没有用户定义的析构

如果三者不能都满足，那么就算使用了移动操作，编译器也不会自动生成，都是报错：没有移动操作；



## `= default` 声明

当编译器自动生成的特殊成员函数是可用的，可以使用 `= default`  显示指出：

````c++
class Widget {
    public:
    … 
    ~Widget();                              //用户声明的析构函数
    …                                       //默认拷贝构造函数
    Widget(const Widget&) = default;        //的行为还可以

    Widget&                                 //默认拷贝赋值运算符
        operator=(const Widget&) = default; //的行为还可以
    … 
};
````

并且一旦对特殊成员函数加上 `= default` 那么编译器就会尽力去生成，不会受到上述条件的限制，甚至可以指定编译器生成所有的特殊成员函数：

````c++
class Base {
public:
    virtual ~Base() = default;              //使析构函数virtual
    
    Base(Base&&) = default;                 //支持移动
    Base& operator=(Base&&) = default;
    
    Base(const Base&) = default;            //支持拷贝
    Base& operator=(const Base&) = default;
    … 
};
````

通常建议，如果需要用到编译器生成的这些特殊成员函数，显示加上 `= default`；

这样代码清晰、并且可以防止一些特殊函数被编译器忽略；



## 特殊函数处理规则

C++11对于特殊成员函数处理的规则如下：

- **默认构造函数**：和 C++98 规则相同。仅当类不存在用户声明的构造函数时才自动生成。
- **析构函数**：基本上和 C++98 相同；稍微不同的是现在析构默认`noexcept`，和 C++98 一样，仅当基类析构为虚函数时该类析构才为虚函数。
- **拷贝构造函数**：和 C++98 运行时行为一样：逐成员拷贝 non-static 数据。仅当类没有用户定义的拷贝构造时才生成。如果类声明了移动操作它就是*delete*的。当用户声明了拷贝赋值或者析构，该函数自动生成已被废弃。
- **拷贝赋值运算符**：和C++98运行时行为一样：逐成员拷贝赋值non-static数据。仅当类没有用户定义的拷贝赋值时才生成。如果类声明了移动操作它就是*delete*的。当用户声明了拷贝构造或者析构，该函数自动生成已被废弃。
- **移动构造函数**和**移动赋值运算符**：都对非static数据执行逐成员移动。仅当类没有用户定义的拷贝操作，移动操作或析构时才自动生成。

要注意如果自定义了析构，拷贝、一旦操作都不会被编译器自动生成；

并且注意，成员函数模板不会影响编译器生成特殊函数：

````c++
class Widget {
    …
    template<typename T>                //从任何东西构造Widget
    Widget(const T& rhs);

    template<typename T>                //从任何东西赋值给Widget
    Widget& operator=(const T& rhs);
    …
};
````

编译器仍会生成移动和拷贝操作；即使 `T` 为 `Widget`，这两个模板函数看起来就是拷贝操作，但编译器还是会产生特殊函数；



## 请记住

- 特殊成员函数是编译器可能自动生成的函数：默认构造函数，析构函数，拷贝操作，移动操作。
- 移动操作仅当类没有显式声明移动操作，拷贝操作，析构函数时才自动生成。
- 拷贝构造函数仅当类没有显式声明拷贝构造函数时才自动生成，并且如果用户声明了移动操作，拷贝构造就是*delete*。拷贝赋值运算符仅当类没有显式声明拷贝赋值运算符时才自动生成，并且如果用户声明了移动操作，拷贝赋值运算符就是*delete*。当用户声明了析构函数，拷贝操作的自动生成已被废弃。
- 成员函数模板不抑制特殊成员函数的生成。



## 问题

结果测试，

- 自定义析构不影响构造拷贝操作与移动操作的生成；
- 移动构造不影响拷贝操作的生成；
- 有拷贝构造不影响拷贝赋值；