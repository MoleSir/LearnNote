# OpenGL

学习 OpenGL 笔记，参考 [LearnOpenGL]([LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/))，主要是对原文的凝练，加上一些个人的理解与课后练习的答案。

- Programs 目录下包含教程的示例与课后练习源码；
- QOpenGLDemos 是 使用 Qt 封装好的 OpenGL 库的源码；
- MineCraft 目录下是实现的一个很简单的 MineCraft，基本上只有渲染图像的功能。

以下为基本的教程大纲与每节的重要知识，只能用作复习。



## 入门

### OpneGL

- 简单介绍了 OpenGL 是什么：OpenGL 本质上一个 API 接口、一种规范；
- 介绍了 OpenGL 的两种模式：理解渲染与核心模式；
- OpenGL 是状态机；
- OpenGL 中对象的概念，以及对 OpenGL 对象的操作流程。

### 配置环境

- GLFW 库实现 OpenGL 规范的函数；
- GLAD 在运行时获取函数地址并将其保存在一个函数指针中供以后使用。

### 创建窗口

- 创建窗口对象；
- 初始化 GLAD 加载 OpenGL 函数指针；
- 调整视口以及视口回调函数；
- 渲染循环。

### 创建三角形

- 三个重要概念：

  - 顶点数组对象：Vertex Array Object，VAO，保存了某个顶点缓冲对象以及其中内存的解释规律；

  - 顶点缓冲对象：Vertex Buffer Object，VBO，保存了某个物体的各个顶点的数据，一个顶点有多个属性，数据可以任意排列，只要通过函数指明即可；

  - 元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO。保存了 OpenGL 绘制物体的时，按照顶点数组中的特定顶点顺序绘制；

- OpenGL 的渲染过程，多个阶段，上一个阶段的输出作为下一关的输入。

- 绘制三角形的过程：

  1. 定义三角形的三个顶点数据；
  2. 创建 VBO 顶点缓冲对象保存数据；
  3. 创建顶点、片段着色器，链接、编译得到着色器程序；
  4. 指定顶点数据的内存分布规则，与数据一起保存到 VAO 顶点数组对象中；
  5. 在每个渲染循环中调用函数绘制三角形。

### 着色器

- 着色器是使用 GLSL 语言描述，为图形计算量身定制。
- 着色器的数据结构，除了 C 中的基本数据类型，还有矩阵、向量等；
- 每个着色器是独立的小程序，可以定义其输入输出（都可以存在多个）；
- Uniform 类型的变量在整个着色程序中共享，只能在程序中通过 OpenGL 提供的特定函数赋值；
- 定义着色器类：从文件中读取着色器程序后加载！

### 纹理

- 纹理就是一张图片，可以在 VBO 中保存某个顶点对应一张图片的哪个位置，将图片绘制出来。

- 一个纹理上的纹理坐标只有 [0, 1] 范围，纹理环绕方式可以定义如果超出这个坐标后会显示什么颜色；

- 纹理过滤将：多个像素点合成为一个像素点；

- 多级渐远纹理：将一张纹理分成若干个小的纹理图像，使得显示小纹理时更加清晰；

- stb_img 库可以读取文件中的图片数据到内存；

- 生成纹理对象：

  1. 创建纹理对象；
  2. 绑定纹理对象；
  3. 使用 stb_img 库读取图片数据到内存；
  4. 将内存中的图片数据加载到纹理对象中。

- 使用纹理对象：

  在片段着色器中定义一个 `uniform` 的 `sampler2D` 对象（本质上就是 int 类型），指向当前程序中的第几号纹理对象，只要设置号这个值，就可以在着色器中利用 `texture` 内建函数使用纹理。

  注意纹理对象对应哪个序号不是创建纹理时候返回的 `unsigned int` 决定，需要先执行：

  ````c++
  glActiveTexture(GL_TEXTUREx);
  ````

  X 可以从 0 到系统支持的最大纹理数量，激活某个序号的纹理；

  再调用：

  ````c
  glBindTexture(GL_TEXTURE_2D, texture);
  ````

  这样 `texture` 这个纹理就绑定到了 `x` 号纹理上，只要给着色器的 `sampler2D` 对象赋值上 x，就可以使用 `texture` 纹理。

### 变换

- 向量的概念与向量的基本运算：点乘与叉乘；
- 矩阵的概念与矩阵的基本运算，特别注意乘法；
- 变换矩阵：让一个向量发生特定的变换，可以使用一个变换矩阵跟其相乘；
- 三种变换矩阵：
  - 缩放：向量的三个维度值缩放特定的值；
  - 位移：向量方向不变，发生平移；
  - 旋转：向量沿着某个轴，旋转特定的角度；
- 由于矩阵的特性，只要给定三种变换的参数、就可以通过变换矩阵与原向量相乘得到变换后的结果；
- 多个变换的组合就是多个变换矩阵，那么可以先把多个变换矩阵乘为一个；
- GLM 库是专门为 OpenGL 设计的实现了矩阵的各类运算的库。

### 坐标系统

- OpenGL 存在多个坐标系统，从程序开始执行到最后绘制出结果，某个点需要进行 5 个坐标系统的变换：

  - 局部空间(Local Space，或者称为物体空间(Object Space))：以某个物体为整体，规定了某个物体的外形；

  - 世界空间(World Space)：若干个物体放置在一个世界中，每个物体又存在一个新的坐标系统；

  - 观察空间(View Space，或者称为视觉空间(Eye Space))：以观察者为原点的世界坐标；

  - 裁剪空间(Clip Space)：将观察空间的中的超出范围的空间去掉；

  - 屏幕空间(Screen Space)：最终程序在屏幕上的坐标；

- 开发者需要关系前四个空间的变换即可，这需要四个变换矩阵（某个点进行变换，也可以理解为某个向量进行变换）

  - model 变换矩阵：从局部空间到世界空间；
  - view 变换矩阵：从空间世界到观察空间；
  - project 变换矩形：从观察空间到裁剪空间；

  $$
  V_{clip} = M_{project} \cdot M_{view} \cdot M_{model} \cdot V_{local}
  $$

  注意三个矩形的先后顺序不能改变；

- 将某个物体进行一点的移动就可以是一个简单的 model 变换矩阵，这样可以让同一个 VAO 进行不同的 model 变换到世界坐标的不同位置；

- project 变换矩阵通常都是规定好的，不需要这么改变；

### 摄像机

- 摄像机就是用来产生 `view` 变换矩阵的；
- 确定一个 `view` 变换矩阵需要：
  - 摄像机的世界坐标位置；
  - 摄像机看向的方向；
  - 定义一个上方的向量；
- 有了三个向量后用 glm 的函数直接生成一个 `lookAt` 矩阵（也就是 `view` 变换矩阵）；
- 摄像机的位置由键盘控制，视角的方向由键盘控制；
- 封装摄像机类，实现 3D 的效果。



## 光照

### 颜色

- 现实世界中产生颜色的规则；
- OpenGL 中模仿这个规则，使用物体颜色向量点乘光照颜色向量得到最后的颜色输出。

### 基础光照

- 冯氏光照模型将现实世界中复杂的光照分为三种：
  - 环境光，无论周围是否存在光源，总有一丝丝细微的光照（通常是很弱的白光）；
  - 漫反射光：光源点乘物体颜色后，还需要乘一个权重：入射光向量与物体表面法向量的点积。这样越光线越 “正” 地射向物体就看着更亮；
  - 反射光：光源点乘物体颜色后，还需要乘一个权重：摄像机看向图片的方向与光线反射方向的点积。这样越看向反射光，反射越明显。

### 材料

- 在着色器中定义一个结构体表示物体的材料，其包含：
  - 环境光反映的颜色，一般就是物体本身的颜色；
  - 漫反射反映的颜色，物体本身的颜色；
  - 反射反映的颜色，一般是白光。
- 在着色器中定义一个结构体表示光源，其包含：
  - 环境光的颜色，一般是很弱的光源颜色；
  - 漫反射的颜色，光源颜色；
  - 反射光的颜色，白光。
- 计算颜色时，将材料与光源结构体中的三个分量相乘后相加得到最后的颜色。

### 光照贴图

- 光照可以运用在纹理上，把表示物品结构体中的环境光、漫反射光反映的颜色字段替换为一个纹理对象。计算颜色的时候使用 `texture` 获取对应位置的颜色即可；
- 镜面光贴图：使用一个纹理作为物体的反射反映的颜色，用 `texture` 取出颜色值，越暗的地方说明反射越弱。

### 投光物

- 平行光：

  ````glsl
  struct Light {
      vec3 direction; // 平行光方向
  
      vec3 ambient;
      vec3 diffuse;
      vec3 specular;
  };
  ````

- 点光源：

  ```glsl
  struct PointLigth
  {
      vec3 position;	// 点光源位置
      
      float constant; // 衰减公式中的常数项系数
      float linear;   // 衰减公式中的一次项系数
      float quadratic;// 衰减公式中的二次项系数
      
      vec3 ambient;
      vec3 diffuse;
      vec3 specular;
  }
  ```

- 聚光（类似手电筒）

  ````glsl
  struct SpotLight {
      vec3  position;	// 光源位置
      vec3  direction;// 手电筒方向
      float cutOff;	// 范围角度的余弦值
  
      vec3 ambient;
      vec3 diffuse;
      vec3 specular;
  };
  ````

### 多光源

多个光源放在一起。修改片段着色器：

```glsl
void main()
{
    // 属性
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // 第一阶段：定向光照
    vec3 result = CalcDirLight(dirLight, norm, viewDir);
    // 第二阶段：点光源
    for(int i = 0; i < NR_POINT_LIGHTS; i++)
        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    
    // 第三阶段：聚光
    //result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    

    FragColor = vec4(result, 1.0);
}
```



## 模型加载

主要介绍了 assimp 库的使用，以及封装 Model 对象。



## 高级 OpenGL

### 深度测试

- 开启深度测试后，OpenGL 保存每一个点渲染点相对屏幕的深度值，每个屏幕位置只会渲染出距离屏幕最近的。实现有物体遮挡的效果；

- 开启深度测试：

  ````c++
  glEnable(GL_DEPTH_TEST);
  ````

### 模板测试

- 模板测试，可以根据某个缓存中的数据，选择屏幕中的某个位置是否被绘制；
- 典型作用：给物体增加边缘效果：
  1. 先绘制物体，并且保存绘制过的位置，在模板测试数据中，绘制过的位置为 1，其他为 0；
  2. 在物体位置绘制一个更大的纯色的物体，此时开启深度，根据模板数据判断：如果绘制的位置是 1 就不绘制，否则就绘制；
  3. 这样使得物体所在的位置不会被覆盖，呈现原物体，当其周围的部分范围呈现边缘的效果。

### 混合

- 混合可以体现物体透明度，根据物体透明度 alpha，一个透明物体物体显示的颜色为：
  $$
  \alpha * 本身颜色 + (1 - \alpha) * 背后的颜色
  $$

- 这是一般的透明物体颜色计算方式，OpenGL 允许自定义其他方式；

- 绘制有透明物体的场景，需要先绘制不透明的，在从远到近绘制透明物体。 

### 面剔除

- 对一个三角形的三个顶点，可以有两种绘制的顺序；

- 在定义三角形绘制方式时，总是站在其正面并且逆时针绘制三个顶点，那么呈现运行时，如果在观察者的角度看，一个三角形面元的绘制方向是逆时针，那么这个面元就正对观察者，否则就背对。

- 开启面剔除：

  ````c++
  glEnable(GL_CULL_FACE);
  ````

  后，OpenGL 会不渲染所有背对观察者的面，提高效率；

- 以上是默认情况，正方向到底顺时针还是逆时针可以由用户自定义，选择绘制背面还是正面的面元也可以由用户定义。

### 帧缓冲

- 帧缓冲是颜色缓冲、深度缓冲和模板缓冲的统称，每次渲染 OpenGL 会把数据保存到默认的屏幕帧缓冲，最后再显示出来；

- 可以创建自己的帧缓冲，并且将将其绑定，那么程序的操作都是对这个自定义的帧缓冲进行。但是操作完后，屏幕也不会有显示，因为只有默认的屏幕帧缓冲才能显示。但确实可以把数据保存到自定义的帧缓冲上；

- 可以先把渲染都保存到自定义帧缓冲中，再从其中读取出最后应该显示的效果到某个纹理对象中，对屏幕的帧缓冲，就只要显示一张纹理即可，很简单；

  1. 把自定义帧缓冲绑定；
  2. 开始绘制；
  3. 绑定到默认屏幕帧缓冲；
  4. 绘制一张纹理到屏幕。

  这样得到的效果跟直接在屏幕缓冲上绘制是一样的；

- 由于最终的所有计算输出了一张简单的纹理，那么屏幕缓冲的着色器就非常简单，那么就可以对处理一张纹理一样，处理最后的输出：

  - 反相，直接在片段着色器让纹理颜色反相；
  - 灰度；
  - 核效果；

### 立方体贴图

- 立方体贴图是由 6 个纹理组成的有个正方体，给定一个向量，放置在立方体中心，延长直到立方体表面，于是就可以确定一个颜色。即一个向量可以确定立方体贴图上的一个颜色点；
- 立方体贴图可以用来绘制天空盒，注意其本质上还是一个有确定大小的立方体，为了营造无限大的效果，需要让摄像机一直保持在立方体中心；
- 还可以利用提取深度测试进行优化。

### 高级数据

- 分批顶点属性！

### 高级 GLSL

- GLSL的内建变量：

  - 顶点着色器变量：
    - `gl_Position`，输出变量，OpenGL 读取这个坐标作为局部裁剪空间坐标；
    - `gl_PointSize`，输出变量，控制绘制点的大小为几个像素；
    - `gl_VertexID`，输入变量，表示当前绘制顶点的 id；
  - 片段着色器变量：
    - `gl_FragCoord`：表示当前绘制的点在屏幕坐标上的位置（左下角为原点，范围是视口大小）。可以用于分频绘制；
    - `gl_FrontFacing`：当前绘制的所属的面元是否是正面。可以用户绘制一个面正反不同纹理的效果；
    - `gl_FragDepth`：输出变量，可以设置当前绘制点屏幕的深度；

- 接口块

  在不同着色器直接数据传输时，定义一整块数据；

- Uniform 缓冲对象，一个程序的不同着色器共用一个 Uniform 数据，不需要多次设置。常见的用于 project 和 view 变换矩阵。

### 几何着色器

- 几何着色器是位于顶点着色器与片段着色器中的一个可选着色器；

- 输入是一种面元的一组顶点（面元是点类型就输入一个顶点，是三角形就输入三个顶点），而输出也可以是一种面元；

  比如输入一个点，输出定义为一个三角形；

- 典型使用方法：

  - 爆破物体：使用几何着色器，输入是三角形，输入也是三角形，并且让三角形按照法线方向移动一段距离；
  - 法向量可视化：使用几何着色器，输入是三角形，输出是线段，绘制出输入三角形的法向量。需要两套着色器，一套正常绘制模型，一套专门计算每个三角形法向量并且绘制；

### 实例化

- 调用渲染函数的开销很大，但很多时间都用在准备工作。如果一个场景存在很多重复的物体，只是位置不一样，不断调用渲染函数就很浪费，可以一次性渲染多个物体，在参数指定出物体数量，这个方法叫做实例化；

- 实例的方法：

  - 在着色器中使用一个 `uniform` 类型是数组保存每个物体的偏移向量，根据 GLSL 内建变量 `gl_InstanceID` 找到当前绘制物体的偏移；

  - 使用属性，直接将偏移向量作为输入到顶点着色器。但这个输入属性比较特别，因为通常一个输入属性在每个顶点都需要变化，但物体的偏移是对整个面元来说都是一样的；

    所以要设置这个属性每一个面源才更新到下一关，而不是每一个顶点；

### 抗锯齿

- 由于屏幕显示是像素的原因，斜线被绘制出放大可能出现锯齿形状；

- 可以使用多重采样技术（MSAA）来抗锯齿：

  1. 创建窗口前：

     ````c++
     glfwWindowHint(GLFW_SAMPLES, 4);
     ````

  2. 场景场景后，开启 MSAA：

     ````c++
     glEnable(GL_MULTISAMPLE);
     ````

     
